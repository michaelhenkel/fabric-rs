pub mod state;

use aya::maps::{MapData, LpmTrie, lpm_trie::Key};
use futures::TryStreamExt;
use tokio::sync::broadcast::error;
use std::{
    ffi::CString,
    io::{Error,ErrorKind}, collections::{HashMap, HashSet}, sync::{Arc, Mutex}, time::Duration, mem, net::{IpAddr, Ipv4Addr}, path::Display, num
};
use network_types::eth::{EtherType::Loop, EthHdr};
use log::{info, error};
use pnet::{
    self, datalink::{DataLinkReceiver, DataLinkSender}, packet::{
        ethernet::{
            MutableEthernetPacket,
            EtherType, EthernetPacket, EtherTypes,
        }, Packet, arp::{MutableArpPacket, ArpHardwareTypes, ArpOperations, ArpPacket}, FromPacket, MutablePacket,
    }, util::MacAddr
};
use rtnetlink::{new_connection, IpVersion};
use netlink_packet_route::route::{RouteAddress::Inet, RouteType};
use netlink_packet_route::{link::LinkAttribute, route::RouteAttribute};
use disco_rs::{DiscoHdr, DiscoRouteHdr, MutableDiscoHdrPacket, MutableDiscoRouteHdrPacket, DiscoHdrPacket, DiscoRouteHdrPacket};
use std::fmt::Display as StdDisplay;
use pnet_macros::Packet;
use fabric_rs_common::{InterfaceConfig, RouteNextHop as RNH};

#[derive(Clone)]
pub struct Interface{
    pub name: String,
    pub ifidx: u32,
    pub ip: Ipv4Addr,
    pub mac: [u8;6],
}

impl Interface{
    pub async fn new(name: String) -> anyhow::Result<Self>{
        let ifidx = match get_interface_index(&name){
            Ok(ifidx) => ifidx,
            Err(e) => {
                return Err(anyhow::anyhow!("failed to get interface index: {:?}", e));
            }
        };
        let ip = match get_interface_ip(&name).await{
            Ok(ip) => ip,
            Err(e) => {
                return Err(anyhow::anyhow!("failed to get interface ip: {:?}", e));
            }
        };
        let mac = match get_local_mac(ifidx).await{
            Ok(Some(mac)) => mac,
            Ok(None) => {
                return Err(anyhow::anyhow!("failed to get local mac"));
            },
            Err(e) => {
                return Err(anyhow::anyhow!("failed to get local mac: {:?}", e));
            }
        };
        Ok(Self{
            name,
            ifidx,
            ip,
            mac,
        })
    }
}



#[derive(Debug, Clone)]
pub struct NeighborTable{
    neighbors: HashMap<u32, Neighbor>
}

impl NeighborTable{
    fn new() -> Self{
        Self{
            neighbors: HashMap::new()
        }
    }
    fn add_neighbor(&mut self, id: u32, neighbor: Neighbor){
        self.neighbors.insert(id, neighbor);
    }
    fn add_interface(&mut self, 
        id: u32,
        neighbor_ip: u32,
        neighbor_mac: [u8;6],
        local_ip: u32,
        local_mac: [u8;6],
        local_ifidx: u32
    ){
        if let Some(neighbor) = self.neighbors.get_mut(&id){
            neighbor.interfaces.insert(neighbor_mac, NeighborInterface{
                neighbor_ip,
                neighbor_mac,
                local_ip,
                local_mac,
                local_ifidx,
            });
        }
    }
    fn exists(&self, id: u32) -> bool{
        self.neighbors.contains_key(&id)
    }
}

#[derive(Debug, Clone)]
struct Neighbor{
    interfaces: HashMap<[u8;6], NeighborInterface>
}

#[derive(Debug, Clone)]
struct NeighborInterface{
    neighbor_ip: u32,
    neighbor_mac: [u8;6],
    local_ip: u32,
    local_mac: [u8;6],
    local_ifidx: u32,
}

#[derive(Debug, Clone)]
pub struct RouteTable{
    routes: HashMap<(u32,u8), Route>
}

impl StdDisplay for RouteTable{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        for ((ip, prefix_len), route) in &self.routes{
            let ip: Ipv4Addr = (*ip).into();
            s.push_str(&format!("\ndst: {}/{}\n\troute: {}\n", ip, prefix_len, route));
        }
        write!(f, "{}", s)
    }
}

impl RouteTable{
    fn new() -> Self{
        Self{
            routes: HashMap::new()
        }
    }
    fn add_route(&mut self, id: u32, prefix_len: u8, route: Route) -> Option<Route>{
        self.routes.insert((id, prefix_len), route)
    }
    fn get_route(&self, id: u32, prefix_len: u8) -> Option<&Route>{
        self.routes.get(&(id, prefix_len))
    }
}

#[derive(Debug, Clone, PartialEq)]
struct Route{
    origin: RouteOrigin,
    next_hops: RouteNextHopList
}

impl StdDisplay for Route{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "\n\t\torigin: {}\n\t\tnext_hops: {}\n", self.origin, self.next_hops)
    }
}

#[derive(Debug, Clone, PartialEq)]
enum RouteOrigin{
    LOCAL,
    REMOTE,
}
impl StdDisplay for RouteOrigin{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self{
            RouteOrigin::LOCAL => write!(f, "LOCAL"),
            RouteOrigin::REMOTE => write!(f, "REMOTE"),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
struct RouteNextHop{
    originator_id: u32,
    ip: u32,
    hops: u32,
    ifidx: u32,
    src_mac: [u8;6],
    dst_mac: [u8;6],
}
impl StdDisplay for RouteNextHop{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let src_mac = MacAddr::from(self.src_mac);
        let dst_mac = MacAddr::from(self.dst_mac);
        let ip: Ipv4Addr = self.ip.into();
        write!(f, "\n\t\t\toriginator_id: {}\n\t\t\tgw: {}\n\t\t\thops: {}\n\t\t\tifidx: {}\n\t\t\tsrc_mac: {}\n\t\t\tdst_mac: {}", self.originator_id, ip, self.hops, self.ifidx, src_mac.to_string(), dst_mac.to_string())
    }
}

#[derive(Debug, Clone, PartialEq)]
struct RouteNextHopList(Vec<RouteNextHop>);

impl StdDisplay for RouteNextHopList{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        for nh in &self.0{
            s.push_str(&nh.to_string());
            s.push_str("\n");
        }
        write!(f, "{}", s)
    }
}

struct State{
    neighbor_table: NeighborTable,
    route_table: RouteTable,
}

#[derive(Clone)]
pub struct UserSpaceClient{
    tx: tokio::sync::mpsc::Sender<Command>,
}

pub enum Command{
    GetRouteTable{
        tx: tokio::sync::oneshot::Sender<RouteTable>,
    },
    GetNeighborTable{
        tx: tokio::sync::oneshot::Sender<NeighborTable>,
    },
    GetForwardingTable{
        tx: tokio::sync::oneshot::Sender<ForwardingTable>,
    },
}

#[derive(Debug, Clone)]
pub struct ForwardingTable{

}

impl UserSpaceClient{
    pub fn new(tx: tokio::sync::mpsc::Sender<Command>) -> Self{
        Self{
            tx
        }
    }
    pub async fn get_route_table(&self) -> anyhow::Result<RouteTable>{
        let (tx, rx) = tokio::sync::oneshot::channel();
        self.tx.send(Command::GetRouteTable{tx}).await?;
        Ok(rx.await?)
    }

    pub async fn get_neighbor_table(&self) -> anyhow::Result<NeighborTable>{
        let (tx, rx) = tokio::sync::oneshot::channel();
        self.tx.send(Command::GetNeighborTable{tx}).await?;
        Ok(rx.await?)
    }

    pub async fn get_forwarding_table(&self) -> anyhow::Result<ForwardingTable>{
        let (tx, rx) = tokio::sync::oneshot::channel();
        self.tx.send(Command::GetForwardingTable{tx}).await?;
        Ok(rx.await?)
    }

}

pub struct UserSpace{

    interfaces: Vec<Interface>,
    sender_channel: Option<tokio::sync::mpsc::Sender<(u32, Vec<u8>)>>,
    state: Arc<tokio::sync::RwLock<State>>,
    id: u32,
    cli: UserSpaceClient,
    rx: Arc<tokio::sync::RwLock<tokio::sync::mpsc::Receiver<Command>>>,
    route_table: Arc<Mutex<LpmTrie<MapData, u32, [RNH;32]>>>,
}

impl UserSpace {
    pub fn new(
        interfaces: Vec<Interface>,
        id: u32,
        route_table: LpmTrie<MapData, u32, [RNH;32]>,
    ) -> Self {
        let (tx, rx) = tokio::sync::mpsc::channel(100);
        UserSpace{
            sender_channel: None,
            interfaces,
            state: Arc::new(tokio::sync::RwLock::new(State{
                neighbor_table: NeighborTable::new(),
                route_table: RouteTable::new(),
            })),
            id,
            cli: UserSpaceClient::new(tx),
            rx: Arc::new(tokio::sync::RwLock::new(rx)),
            route_table: Arc::new(Mutex::new(route_table)),
        }
    }

    pub fn cli(&self) -> UserSpaceClient{
        self.cli.clone()
    }

    pub async fn cli_server(&self) -> anyhow::Result<tokio::task::JoinHandle<()>>{
        let rx = self.rx.clone();
        let state = self.state.clone();
        let forwarding_table = self.route_table.clone();
        
        let jh = tokio::spawn(async move{
            let mut rx = rx.write().await;
            loop{
                while let Some(command) = rx.recv().await{
                    let state = state.write().await;
                    let forwarding_table = forwarding_table.lock().unwrap();
                    match command{
                        Command::GetNeighborTable { tx } => {
                            let neighbor_table = state.neighbor_table.clone();
                            tx.send(neighbor_table).unwrap();
                        },
                        Command::GetRouteTable { tx } => {
                            let route_table = state.route_table.clone();
                            tx.send(route_table).unwrap();
                        },
                        Command::GetForwardingTable { tx } => {

                            for res in forwarding_table.iter(){
                                
                                if let Ok((k,v)) = res{
                                    let ip = Ipv4Addr::from(k.data());
                                    let mut output = format!("\ndst: {}/{} -> \n", ip, k.prefix_len());
                                    for nh in &v{
                                        if nh.ip != 0 {
                                            let ip: Ipv4Addr = nh.ip.into();
                                            let nh_string = format!("\t\t\tgw: {}\n\t\t\tifidx: {}\n\t\t\tsrc_mac: {}\n\t\t\tdst_mac: {}\n", ip, nh.ifidx, MacAddr::from(nh.src_mac).to_string(), MacAddr::from(nh.dst_mac).to_string());
                                            output.push_str(&nh_string);
                                        }
                                    }
                                    println!("{}", output);
                                }
                            }
                            let forwarding_table = ForwardingTable{};
                            tx.send(forwarding_table).unwrap();
                        },
                    }
                }
            }
        });
        Ok(jh)
    }

    pub async fn init(&mut self) -> anyhow::Result<()>{

        match self.get_local_routes().await{
            Ok(route_list) => {
                for ((prefix, prefix_len), route_attr) in &route_list{
                    if *prefix_len != 32 {
                        continue;
                    }
                    let mut local_interface = None;
                    for interface in &self.interfaces{
                        if interface.ifidx == route_attr.ifidx{
                            local_interface = Some(interface.clone());
                        }
                    }
                    if let Some(local_interface) = local_interface{
                        match route_attr.kind{
                            RouteType::Local => {
                                let src_mac: [u8;6] = route_attr.mac.clone().into();
                                let dst_mac: [u8;6] = src_mac.clone();
                                let route = Route{
                                    origin: RouteOrigin::LOCAL,
                                    next_hops: RouteNextHopList(vec![
                                        RouteNextHop{
                                            originator_id: self.id,
                                            ip: *prefix,
                                            hops: 0,
                                            ifidx: route_attr.ifidx,
                                            src_mac,
                                            dst_mac,
                                        }
                                    ])
                                };
                                self.state.write().await.route_table.add_route(*prefix, *prefix_len, route);
                                let mut route_next_hops: [RNH;32] = [RNH{
                                    ip: 0,
                                    ifidx: 0,
                                    src_mac: [0;6],
                                    dst_mac: [0;6],
                                    total_next_hops: 0,
                                };32];
                                route_next_hops[0] = RNH{
                                    ip: *prefix,
                                    ifidx: route_attr.ifidx,
                                    src_mac,
                                    dst_mac,
                                    total_next_hops: 0,
                                };
                                let key = Key::new(*prefix_len as u32, *prefix);
                                self.route_table.lock().unwrap().insert(&key, route_next_hops, 0).unwrap();

                            },
                            RouteType::Unicast => {
                                /*
                                let dst_mac = match send_arp(Ipv4Addr::from(prefix.clone()), local_interface.ip, route_attr.ifidx, route_attr.mac.clone()).await{
                                    Ok(res) => {
                                        if let Some(dst_mac) = res {
                                            dst_mac
                                        } else {
                                            continue;
                                        }
                                    }
                                    Err(e) => {
                                        error!("failed to send arp: {:?}", e);
                                        continue;
                                    }
                                };
                                let src_mac: [u8;6] = route_attr.mac.clone().into();
                                let dst_mac: [u8;6] = dst_mac.into();
                                let route = Route{
                                    origin: RouteOrigin::LOCAL,
                                    next_hops: RouteNextHopList(vec![
                                        RouteNextHop{
                                            originator_id: self.id,
                                            ip: *prefix,
                                            hops: 0,
                                            ifidx: route_attr.ifidx,
                                            src_mac,
                                            dst_mac,
                                        }
                                    ])
                                };
                                self.state.lock().unwrap().route_table.add_route(*prefix, *prefix_len, route);
                                let mut route_next_hops: [RNH;32] = [RNH{
                                    ip: 0,
                                    ifidx: 0,
                                    src_mac: [0;6],
                                    dst_mac: [0;6],
                                    total_next_hops: 0,
                                };32];
                                route_next_hops[0] = RNH{
                                    ip: *prefix,
                                    ifidx: route_attr.ifidx,
                                    src_mac,
                                    dst_mac,
                                    total_next_hops: 0,
                                };
                                let key = Key::new(*prefix_len as u32, *prefix);
                                self.route_table.lock().unwrap().insert(&key, route_next_hops, 0).unwrap();
                                */
                            },
                            _ => {}
                        }
                    }

                }
                info!("init done");
            },
            Err(e) => {
                return Err(anyhow::anyhow!("failed to get local routes: {:?}", e));
            }
        }
        Ok(())
    }

    pub async fn route_sender(&mut self) -> anyhow::Result<tokio::task::JoinHandle<()>>{
        let mut interval = tokio::time::interval(Duration::from_secs(4));
        let local_id = self.id;
        let state = self.state.clone();
        let sender_channel = self.sender_channel.as_ref().unwrap().clone();
        let jh = tokio::spawn(async move{
            loop{
                tokio::select! {
                    _ = interval.tick() => {
                        info!("route sender");
                        let state = state.read().await;
                        for (id, neighbor) in &state.neighbor_table.neighbors{
                            info!("sending routes to neighbor {}", id);
                            for (mac, interface) in &neighbor.interfaces{
                                info!("sending routes to neighbor {} on interface {}", id, interface.local_ifidx);
                                let mut routes = Vec::new();
                                for ((prefix, len), route) in &state.route_table.routes{
                                    let mut from_neighbor = false;
                                    let mut hops = 1;
                                    for nh in &route.next_hops.0{
                                        if nh.originator_id == *id{
                                            from_neighbor = true;
                                            break;
                                        }
                                        hops = nh.hops;
                                    }
                                    if !from_neighbor{
                                        let hops = match route.origin{
                                            RouteOrigin::LOCAL => {
                                                1
                                            },
                                            RouteOrigin::REMOTE => {
                                                hops + 1
                                            },
                                        };
                                        routes.push((*prefix, hops, *len));
                                    }
                                }
                                if routes.len() == 0{
                                    info!("no routes to send");
                                    continue;
                                }
                                let buffer_size = EthHdr::LEN + DiscoHdr::LEN + routes.len() * DiscoRouteHdr::LEN;
                                let mut ethernet_buffer = vec![0u8; buffer_size];
                                let ethernet_buffer = ethernet_buffer.as_mut_slice();
                                
                                let mut ethernet_packet = MutableEthernetPacket::new(ethernet_buffer).unwrap();
                                ethernet_packet.set_destination(mac.clone().into());
                                ethernet_packet.set_source(interface.local_mac.into());
                                ethernet_packet.set_ethertype(EtherType(0x0060));

                                let buffer_size = DiscoHdr::LEN + routes.len() * DiscoRouteHdr::LEN;
                                let mut disco_buffer = vec![0u8; buffer_size];
                                let disco_buffer = disco_buffer.as_mut_slice();
                                let mut disco_packet = MutableDiscoHdrPacket::new(disco_buffer).unwrap();
                                disco_packet.set_id(local_id);
                                disco_packet.set_ip(interface.local_ip);
                                disco_packet.set_op(1);

                                let mut rp_list = Vec::new();
                                for (prefix, hops, len) in routes{
                                    let buffer_size = DiscoRouteHdr::LEN;
                                    let mut route_packet_buffer = vec![0u8; buffer_size];
                                    let route_packet_buffer = route_packet_buffer.as_mut_slice();
                                    let mut rp = MutableDiscoRouteHdrPacket::new(route_packet_buffer).unwrap();
                                    rp.set_ip(prefix);
                                    rp.set_hops(hops);
                                    rp.set_prefix_len(len);
                                    let l = rp.packet().to_vec();
                                    rp_list.extend(l);
                                }
                                let rp_list = rp_list.as_mut_slice();
                                disco_packet.set_payload(&rp_list);
                                //info!("sending disco route packet {}", disco_packet);
                                ethernet_packet.set_payload(disco_packet.packet());

                                sender_channel.send((interface.local_ifidx, ethernet_packet.packet().to_vec())).await.unwrap();
                            }
                        }
                    }
                }
            }
        });
        Ok(jh)
    }

    pub async fn disco_sender(&mut self) -> anyhow::Result<tokio::task::JoinHandle<()>>{
        let mut interval = tokio::time::interval(Duration::from_secs(2));
        let interfaces = self.interfaces.clone();
        let sender_channel = self.sender_channel.as_ref().unwrap().clone();
        let id = self.id;
        let jh = tokio::spawn(async move {
            loop {
		    	tokio::select! {
                    _ = interval.tick() => {
                        info!("sending disco packet");
                        let all_interfaces = pnet::datalink::interfaces();
                        for interface in &interfaces{
                            let data_link_interface = if let Some(interface) = all_interfaces
                                .iter()
                                .find(|e| e.index == interface.ifidx){
                                    interface
                            } else {
                                panic!("interface not found");
                            };

                            let(mut tx, mut _rx) = match pnet::datalink::channel(data_link_interface, Default::default()) {
                                Ok(pnet::datalink::Channel::Ethernet(tx, rx)) => (tx, rx),
                                Ok(_) => panic!("Unknown channel type"),
                                Err(e) => panic!("Error happened {}", e),
                            };

                            let mut ethernet_buffer = [0u8; EthHdr::LEN + 9];
                            let mut ethernet_packet = MutableEthernetPacket::new(&mut ethernet_buffer).unwrap();
                        
                            ethernet_packet.set_destination(MacAddr::broadcast());
                            ethernet_packet.set_source(interface.mac.into());
                            ethernet_packet.set_ethertype(EtherType(0x0060));
                            let mut disco_buffer = [0u8; 9];
                            let mut disco_packet = MutableDiscoHdrPacket::new(&mut disco_buffer).unwrap();
                            disco_packet.set_id(id);
                            disco_packet.set_ip(u32::from_be_bytes(interface.ip.octets()));
                            disco_packet.set_op(0);
                            //info!("sending disco packet {}", disco_packet);

                            ethernet_packet.set_payload(disco_packet.packet());
                            sender_channel.send((interface.ifidx, ethernet_packet.packet().to_vec())).await.unwrap();
                        }
                        
                    }
                }
            }
        });
        Ok(jh)
    }

    pub async fn send(&mut self, ifidx: u32, msg: Vec<u8>) -> anyhow::Result<()>{
        if let Some(sender_channel) = &self.sender_channel{
            sender_channel.send((ifidx,msg)).await?;
        }
        Ok(())
    }

    pub async fn recv(&mut self, mut rx: tokio::sync::mpsc::Receiver<Vec<u8>>) -> anyhow::Result<tokio::task::JoinHandle<()>>{
        let jh = tokio::spawn(async move{
            loop{
                while let Some(msg) = rx.recv().await{
                    if let Some(eth_hdr) = EthernetPacket::new(&msg){
                        if eth_hdr.get_ethertype() != EtherType(0x0060) {
                            continue;
                        }
                        //DiscoHdrPacket::new(eth_hdr.payload()).u
                    }
                }
            }
        });
        Ok(jh)
    }

    async fn send_recv(&mut self, tx: tokio::sync::mpsc::Sender<Vec<u8>>, mut rx: tokio::sync::mpsc::Receiver<(u32, Vec<u8>)>) -> anyhow::Result<Vec<tokio::task::JoinHandle<()>>>{
        let mut jh_list = Vec::new();
        let all_interfaces = pnet::datalink::interfaces();
        let mut sender_list = HashMap::new();
        for interface in &self.interfaces{
            let data_link_interface = if let Some(interface) = all_interfaces
                .iter()
                .find(|e| e.index == interface.ifidx){
                    interface
            } else {
                panic!("interface not found");
            };

            let(dl_tx, mut dl_rx) = match pnet::datalink::channel(data_link_interface, Default::default()) {
                Ok(pnet::datalink::Channel::Ethernet(tx, rx)) => (tx, rx),
                Ok(_) => panic!("Unknown channel type"),
                Err(e) => panic!("Error happened {}", e),
            };
            sender_list.insert(interface.ifidx, dl_tx);
            let tx = tx.clone();
            let jh = tokio::spawn(async move{
                loop{
                    let buf = dl_rx.next().unwrap();
                    tx.send(buf.to_vec()).await.unwrap();
                }
            });
            jh_list.push(jh);
        }
        
        let jh = tokio::spawn(async move{
            loop{
                while let Some((ifidx, msg)) = rx.recv().await{
                    if let Some(tx) = sender_list.get_mut(&ifidx){
                        if let Some(res) = tx.send_to(msg.as_slice(), None) {
                            match res {
                                Ok(_) => {
                                    info!("message sent");
                                },
                                Err(e) => {
                                    panic!("failed to send packet: {:?}", e);
                                }
                            }
                        } else {
                            panic!("failed to send packet");
                        }
                    }
                }
            }
        });
        jh_list.push(jh);
        Ok(jh_list)
    }


    pub async fn receiver(&mut self) -> anyhow::Result<Vec<tokio::task::JoinHandle<()>>>{
        let all_interfaces = pnet::datalink::interfaces();
        let mut jh_list = Vec::new();
        for interface in &self.interfaces{
            let interface = interface.clone();
            let data_link_interface = if let Some(interface) = all_interfaces
                .iter()
                .find(|e| e.name == interface.name){
                    interface
            } else {
                panic!("interface not found");
            };
            let mut config: pnet::datalink::Config = Default::default();
            let(mut _tx, mut rx) = match pnet::datalink::channel(data_link_interface, config) {
                Ok(pnet::datalink::Channel::Ethernet(tx, rx)) => (tx, rx),
                Ok(_) => panic!("Unknown channel type"),
                Err(e) => panic!("Error happened {}", e),
            };
            let state = self.state.clone();
            let route_table = self.route_table.clone();
            let jh = tokio::spawn(async move{
                loop {
                    info!("waiting for packet");
                    let buf = rx.next().unwrap();
                    info!("received packet");
                    if let Some(eth_hdr) = EthernetPacket::new(buf){
                        if eth_hdr.get_ethertype() == EtherType(0x0060) && eth_hdr.get_source() != interface.mac{
                            let disco_hdr_packet = match DiscoHdrPacket::new(eth_hdr.payload()){
                                Some(disco_hdr) => disco_hdr,
                                None => {
                                    error!("failed to convert eth_hdr payload to disco_hdr");
                                    continue;
                                }
                            };
                            //info!("received disco packet {}", disco_hdr_packet);
                            if disco_hdr_packet.get_op() == 0{
                                info!("received disco packet {}", disco_hdr_packet);
                                let mut state = state.write().await;
                                if !state.neighbor_table.exists(disco_hdr_packet.get_id()){
                                    state.neighbor_table.add_neighbor(disco_hdr_packet.get_id(), Neighbor{
                                        interfaces: HashMap::new()
                                    });
                                }
                                state.neighbor_table.add_interface(
                                    disco_hdr_packet.get_id(),
                                    disco_hdr_packet.get_ip(), 
                                    eth_hdr.get_source().into(),
                                    u32::from_be_bytes(interface.ip.octets()),
                                    interface.mac.clone(),
                                    interface.ifidx,
                                );
                            } else if disco_hdr_packet.get_op() == 1{
                                /*
                                info!("received disco route packet {}", disco_hdr_packet);
                                if disco_hdr_packet.payload().len() == 0 {
                                    continue;
                                }
                                //let number_of_route_hdrs = disco_hdr.get_len() as usize / DiscoRouteHdr::LEN;
                                let number_of_route_hdrs = disco_hdr_packet.payload().len() / 9;


                                let route_hdr_size = disco_hdr_packet.payload().len()/number_of_route_hdrs;
                                for i in 0..number_of_route_hdrs{
                                    let offset = i * route_hdr_size;
                                    let pl = &disco_hdr_packet.payload()[offset..offset + route_hdr_size];
                                    let disco_route_header: &[u8;9] = pl.try_into().unwrap();
                                    let route_hdr = DiscoRouteHdrPacket::new(disco_route_header).unwrap();
                                    let mut state = state.lock().unwrap();
                                    if let Some(route) = state.route_table.get_route(disco_hdr_packet.get_id(), route_hdr.get_prefix_len()){
                                        let mut route = route.clone();
                                        let mut same_hops = Vec::new();
                                        let mut less_hops = Vec::new();
                                        let mut more_hops = Vec::new();
                                        let rh = RouteNextHop{
                                            originator_id: disco_hdr_packet.get_id(),
                                            ip: disco_hdr_packet.get_ip(),
                                            hops: route_hdr.get_hops(),
                                            ifidx: interface.ifidx,
                                            src_mac: eth_hdr.get_source().into(),
                                            dst_mac: eth_hdr.get_destination().into(),
                                        };
                                        for nh in &route.next_hops.0{
                                            if route_hdr.get_hops() > nh.hops{
                                                more_hops.push(nh.clone());    
                                            }
                                            if route_hdr.get_hops() == nh.hops{
                                                same_hops.push(nh.clone());
                                            }
                                            if route_hdr.get_hops() < nh.hops{
                                                less_hops.push(rh.clone());
                                            }
                                        }
                                        if less_hops.len() > 0 {
                                            route.next_hops.0 = less_hops;
                                        } else if same_hops.len() > 0 {
                                            route.next_hops.0.push(rh.clone());
                                        } else if more_hops.len() > 0 {
                                            route.next_hops.0 = more_hops;
                                        }
                                        if let Some(old_route) = state.route_table.add_route(route_hdr.get_ip(), route_hdr.get_prefix_len(), route.clone()){
                                            //if old_route != route{
                                                let mut route_next_hops: [RNH;32] = [RNH{
                                                    ip: 0,
                                                    ifidx: 0,
                                                    src_mac: [0;6],
                                                    dst_mac: [0;6],
                                                    total_next_hops: 0,
                                                };32];
                                                for (idx, nh) in route.next_hops.0.iter().enumerate(){
                                                    let rnh = RNH{
                                                        ip: nh.ip,
                                                        ifidx: nh.ifidx,
                                                        src_mac: nh.src_mac,
                                                        dst_mac: nh.dst_mac,
                                                        total_next_hops: route.next_hops.0.len() as u32,
                                                    };
                                                    route_next_hops[idx] = rnh;
                                                }
                                                let key = Key::new(route_hdr.get_prefix_len() as u32, route_hdr.get_ip());
                                                route_table.lock().unwrap().insert(&key, route_next_hops, 0).unwrap();
                                            //}
                                        }
                                    } else {
                                        let route = Route{
                                            origin: RouteOrigin::REMOTE,
                                            next_hops: RouteNextHopList(vec![RouteNextHop{
                                                originator_id: disco_hdr_packet.get_id(),
                                                ip: disco_hdr_packet.get_ip(),
                                                hops: route_hdr.get_hops(),
                                                ifidx: interface.ifidx,
                                                src_mac: eth_hdr.get_source().into(),
                                                dst_mac: eth_hdr.get_destination().into(),
                                            }])
                                        };
                                        if let Some(old_route) = state.route_table.add_route(route_hdr.get_ip(), route_hdr.get_prefix_len(), route.clone()){
                                            //if old_route != route{
                                                let mut route_next_hops: [RNH;32] = [RNH{
                                                    ip: 0,
                                                    ifidx: 0,
                                                    src_mac: [0;6],
                                                    dst_mac: [0;6],
                                                    total_next_hops: 0,
                                                };32];
                                                for (idx, nh) in route.next_hops.0.iter().enumerate(){
                                                    let rnh = RNH{
                                                        ip: nh.ip,
                                                        ifidx: nh.ifidx,
                                                        src_mac: nh.src_mac,
                                                        dst_mac: nh.dst_mac,
                                                        total_next_hops: route.next_hops.0.len() as u32,
                                                    };
                                                    route_next_hops[idx] = rnh;
                                                }
                                                let key = Key::new(route_hdr.get_prefix_len() as u32, route_hdr.get_ip());
                                                route_table.lock().unwrap().insert(&key, route_next_hops, 0).unwrap();
                                            //}
                                        }
                                    }
                                    //info!("route table: {}", state.route_table);
                                }
                                */
                            } else {
                                info!("unknown disco packet op: {}", disco_hdr_packet.get_op());
                            }
                        }
                    };
                }
            });
            jh_list.push(jh);
        }
        
        Ok(jh_list)
    }

    pub async fn run(&mut self) -> anyhow::Result<()> {
        let mut jh_list = Vec::new();
        let jh = self.cli_server();
        jh_list.push(jh.await?);

        let (send_tx, send_rx) = tokio::sync::mpsc::channel(100);
        let (recv_tx, recv_rx) = tokio::sync::mpsc::channel(100);

        self.sender_channel = Some(recv_tx.clone());

        let jh = self.send_recv(send_tx, recv_rx);
        jh_list.extend(jh.await?);

        let jh = self.recv(send_rx);
        jh_list.push(jh.await?);

        let jh = self.disco_sender();
        jh_list.push(jh.await?);
        
        let jh = self.route_sender();
        jh_list.push(jh.await?);
        
        
        //let jh = self.receiver();
        //jh_list.extend(jh.await?);
        
        futures::future::join_all(jh_list).await;
        Ok(())
    }
    async fn get_local_routes(&self) -> anyhow::Result<HashMap<(u32,u8), RouteAttr>>{
        let (connection, handle, _) = new_connection().unwrap();
        tokio::spawn(connection);
        let mut routes = handle.route().get(IpVersion::V4).execute();
        let mut route_list = HashMap::new();
        
        let local_interfaces = self.interfaces.clone();
        while let Some(route_msg) = routes.try_next().await? {
            for attr in &route_msg.attributes{
                match attr{
                    RouteAttribute::Oif(oif) => {
                        for local_interface in &local_interfaces{
                            if local_interface.ifidx == *oif{
                                for attr in &route_msg.attributes{
                                    //info!("route attribute: {:?}", attr);
                                    match attr{
                                        RouteAttribute::Destination(dest) => {
                                            match dest{
                                                Inet(inet) => {
                                                    let route_attr = RouteAttr{
                                                        ifidx: *oif,
                                                        kind: route_msg.header.kind,
                                                        mac: MacAddr::from(local_interface.mac),
                                                    };
                                                    route_list.insert((u32::from_be_bytes(inet.octets()), route_msg.header.destination_prefix_length), route_attr);
                                                },
                                                _ => {},
                                            }
                                        },
                                        _ => {},
                                    }
                                }
                            }
                        }
                    },
                    _ => {},
                }
            }
        }
        Ok(route_list)
    }
}

struct RouteAttr{
    ifidx: u32,
    kind: RouteType,
    mac: MacAddr
}

struct Buffer {
    buffer: Vec<u8>,
}

impl Buffer{
    fn new() -> Self{
        Self{
            buffer: Vec::new(),
        }
    }
    fn add<T>(&mut self, t: T) -> &mut Self{
        let buf = unsafe {
            let ptr = &t as *const T as *const u8;
            std::slice::from_raw_parts(ptr, std::mem::size_of::<T>())
        };
        self.buffer.extend_from_slice(buf);
        self
    }
    fn as_slice(&self) -> &[u8]{
        self.buffer.as_slice()
    }
}

fn get_interface_index(interface_name: &str) -> Result<u32, Error> {
    let interface_name_cstring = CString::new(interface_name)?;
    let interface_index = unsafe { libc::if_nametoindex(interface_name_cstring.as_ptr()) };
    if interface_index == 0 {
        Err(Error::new(ErrorKind::NotFound, format!("Interface not found {}", interface_name)))
    } else {
        Ok(interface_index)
    }
}

fn get_data_link_interface_by_index(ifidx: u32) -> anyhow::Result<pnet::datalink::NetworkInterface>{
    let all_interfaces = pnet::datalink::interfaces();
    let interface = if let Some(interface) = all_interfaces
        .iter()
        .find(|e| e.index == ifidx){
            interface
    } else {
        panic!("interface not found");
    };
    Ok(interface.clone())
}

async fn get_interface_ip(interface_name: &str) -> anyhow::Result<Ipv4Addr>{
    let all_interfaces = pnet::datalink::interfaces();
    let interface = if let Some(interface) = all_interfaces
        .iter()
        .find(|e| e.name == interface_name.to_string()){
            interface
    } else {
        panic!("interface not found");
    };
    for ip in &interface.ips{
        if ip.is_ipv4(){
           match ip.ip(){
                std::net::IpAddr::V4(ip) => {
                    return Ok(ip);
                },
                _ => {}
            }
        }
    };    
    Err(anyhow::anyhow!("no ip found"))
}

async fn get_local_mac(index: u32) -> anyhow::Result<Option<[u8;6]>> {
    let (connection, handle, _) = new_connection().unwrap();
    tokio::spawn(connection);
    let mut links = handle.link().get().match_index(index).execute();
    let msg = if let Some(msg) = links.try_next().await? {
        msg
    } else {
        error!("no link with index {index} found");
        return Ok(None);
    };
    assert!(links.try_next().await?.is_none());

    for attr in msg.attributes.into_iter() {
        match attr{
            LinkAttribute::Address(addr) => {
                let array: [u8; 6] = addr.try_into().map_err(|v: Vec<u8>| {
                    anyhow::anyhow!("Expected a Vec of length {} but it was {}", 6, v.len())
                })?;
                return Ok(Some(array))
            },
            _ => {}
        }
    }
    Ok(None)
}

async fn send_arp(dst_ip: Ipv4Addr, src_ip: Ipv4Addr, intf_idx: u32, src_mac: MacAddr) -> anyhow::Result<Option<pnet::datalink::MacAddr>> {
    let all_interfaces = pnet::datalink::interfaces();
    let interface = if let Some(interface) = all_interfaces
        .iter()
        .find(|e| e.index == intf_idx){
            interface
    } else {
        panic!("interface not found");
    };

    let mut config = pnet::datalink::Config::default();
    config.read_timeout = Some(std::time::Duration::from_secs(1));

    let(mut tx, mut rx) = match pnet::datalink::channel(interface, config) {
        Ok(pnet::datalink::Channel::Ethernet(tx, rx)) => (tx, rx),
        Ok(_) => panic!("Unknown channel type"),
        Err(e) => panic!("Error happened {}", e),
    };

    let mut ethernet_buffer = [0u8; 42];
    let mut ethernet_packet = MutableEthernetPacket::new(&mut ethernet_buffer).unwrap();

    ethernet_packet.set_destination(MacAddr::broadcast());
    ethernet_packet.set_source(src_mac);
    ethernet_packet.set_ethertype(EtherTypes::Arp);

    let mut arp_buffer = [0u8; 28];
    let mut arp_packet = MutableArpPacket::new(&mut arp_buffer).unwrap();

    arp_packet.set_hardware_type(ArpHardwareTypes::Ethernet);
    arp_packet.set_protocol_type(EtherTypes::Ipv4);
    arp_packet.set_hw_addr_len(6);
    arp_packet.set_proto_addr_len(4);
    arp_packet.set_operation(ArpOperations::Request);
    arp_packet.set_sender_hw_addr(src_mac);
    arp_packet.set_sender_proto_addr(src_ip);
    arp_packet.set_target_hw_addr(MacAddr::broadcast());
    arp_packet.set_target_proto_addr(dst_ip);

    info!("sending arp packet. src_mac {}, dst_mac {}, src_ip {}, dst_ip {}", src_mac, MacAddr::broadcast(), src_ip, dst_ip);

    ethernet_packet.set_payload(arp_packet.packet());
    if let Some(res) = tx.send_to(ethernet_packet.packet(), None) {
        match res {
            Ok(_) => {
                info!("arp packet sent");
            },
            Err(e) => {
                panic!("failed to send packet: {:?}", e);
            }
        }
    } else {
        panic!("failed to send packet");
    }

    loop {        
        let buf = match rx.next(){
            Ok(buf) => buf,
            Err(e) => {
                if e.kind() == std::io::ErrorKind::TimedOut{
                    error!("timed out waiting for arp reply");
                    return Ok(None);
                } else {
                    return Err(anyhow::anyhow!("failed to receive packet: {:?}", e));
                }
            }
        };
        let arp = match ArpPacket::new(&buf[MutableEthernetPacket::minimum_packet_size()..]){
            Some(arp) => arp,
            None => {
                error!("failed to convert eth_hdr payload to arp");
                continue;
            }
        };
        if arp.get_sender_proto_addr() == dst_ip
            && arp.get_target_hw_addr() == interface.mac.unwrap()
        {
            println!("Received reply");
            return Ok(Some(arp.get_sender_hw_addr()));
        }

    }
}

